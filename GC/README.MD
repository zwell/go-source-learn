# 垃圾回收（GC）

Go 运行时的垃圾回收（Garbage Collection，GC）采用 **并发标记-清除**（Concurrent Mark and Sweep）策略，结合三色标记算法和后台并行工作者（work 线程）实现高效的内存管理。

## 目录

- [GC 主流程](GC.md)
- [标记阶段](GC-mark.md)
- [清扫阶段](GC-sweep.md)
- [GC 工作者（work 线程）](GC-work.md)

## 简介

Go 的 GC 主要分为以下几个核心阶段：

- **GC 主流程**：协调整个垃圾回收过程，包括触发条件、STW（Stop-the-World）暂停管理等。
- **标记阶段**：使用三色标记算法扫描对象引用，区分存活对象和垃圾对象。
- **清扫阶段**：释放未被标记的对象，回收内存。
- **GC 工作者（work 线程）**：多个 GC 线程并行处理标记和清扫任务，以提高 GC 效率。

## 细节解析

### **1. GC 主流程**
GC 由 Go 运行时自动触发，流程包括：
1. 触发 GC（手动调用 `runtime.GC()` 或由运行时决定）。
2. STW（短暂停止世界，防止并发修改对象）。
3. 启动 GC 工作者并并发执行标记阶段。
4. 完成标记后，执行清扫阶段释放无用对象。
5. 结束 GC，恢复程序执行。

### **2. 标记阶段**
采用 **三色标记算法**：
- **白色**：尚未被扫描的对象，最终会被回收。
- **灰色**：已发现但仍未扫描完毕的对象。
- **黑色**：已扫描并确认存活的对象。

GC 线程会遍历对象图，扫描引用关系，将存活对象标记为黑色，其引用对象加入灰色队列，最终未被标记的对象即为垃圾。

### **3. 清扫阶段**
清扫阶段会：
- 释放未被标记（白色）的对象。
- 归还部分空闲页给操作系统，减少内存占用。

### **4. GC 工作者（work 线程）**
为了降低 STW 影响，Go 的 GC 采用 **并行 GC 线程** 来完成标记和清扫任务。这些线程会：
- 并行扫描对象，减少主线程负担。
- 处理全局 GC 队列，提高吞吐量。
- 在后台运行，尽量减少程序的 GC 停顿时间。